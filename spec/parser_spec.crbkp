#require 'stringio'
require "./spec_helper"

include Optimist
describe Optimist::Parser do

  parser = Optimist::Parser.new
  
  Spec.before_each do
    parser = Optimist::Parser.new
  end

  it "has a version" do
    (parser.version).should be_nil
    parser.version = "optimist 5.2.3" 
    parser.version.should eq "optimist 5.2.3"
  end

  it "has a usage" do
    parser.usage.should be_nil
    parser.usage = "usage string" 
    parser.usage.should eq "usage string"
  end

  it "has a synopsis" do
    parser.synopsis.should be_nil
    parser.synopsis = "synopsis string" 
    parser.synopsis.should eq "synopsis string"
  end
#
#  # def test_depends
#  # def test_conflicts
#  # def test_stop_on
#  # def test_stop_on_unknown
#
#  # die
#  # def test_die_educate_on_error
#
#
#  def test_unknown_arguments
#    err = expect_raises(CommandlineError) { parser.parse(%w(--arg)) }
#    assert_match(/unknown argument '--arg'/, err.message)
#    parser.opt "arg"
#    parser.parse(%w(--arg))
#    err = expect_raises(CommandlineError) { parser.parse(%w(--arg2)) }
#    assert_match(/unknown argument '--arg2'/, err.message)
#  end
#  
#  def test_unknown_arguments_with_suggestions
#    sugp = Parser.new(:suggestions => true)
#    err = expect_raises(CommandlineError) { sugp.parse(%w(--bone)) }
#    assert_match(/unknown argument '--bone'$/, err.message)
#
#    if (Module::const_defined?("DidYouMean") &&
#        Module::const_defined?("DidYouMean::JaroWinkler") &&
#        Module::const_defined?("DidYouMean::Levenshtein"))
#      sugp.opt "cone"
#      sugp.parse(%w(--cone))
#
#      # single letter mismatch
#      err = expect_raises(CommandlineError) { sugp.parse(%w(--bone)) }
#      assert_match(/unknown argument '--bone'.  Did you mean: \[--cone\] \?$/, err.message)
#
#      # transposition
#      err = expect_raises(CommandlineError) { sugp.parse(%w(--ocne)) }
#      assert_match(/unknown argument '--ocne'.  Did you mean: \[--cone\] \?$/, err.message)
#
#      # extra letter at end
#      err = expect_raises(CommandlineError) { sugp.parse(%w(--cones)) }
#      assert_match(/unknown argument '--cones'.  Did you mean: \[--cone\] \?$/, err.message)
#
#      # too big of a mismatch to suggest (extra letters in front)
#      err = expect_raises(CommandlineError) { sugp.parse(%w(--snowcone)) }
#      assert_match(/unknown argument '--snowcone'$/, err.message)
#
#      # too big of a mismatch to suggest (nothing close)
#      err = expect_raises(CommandlineError) { sugp.parse(%w(--clown-nose)) }
#      assert_match(/unknown argument '--clown-nose'$/, err.message)
#
#      sugp.opt "zippy"
#      sugp.opt "zapzy"
#      # single letter mismatch, matches two
#      err = expect_raises(CommandlineError) { sugp.parse(%w(--zipzy)) }
#      assert_match(/unknown argument '--zipzy'.  Did you mean: \[--zippy, --zapzy\] \?$/, err.message)
#
#      sugp.opt "big_bug"
#      # suggest common case of dash versus underscore in argnames
#      err = expect_raises(CommandlineError) { sugp.parse(%w(--big_bug)) }
#      assert_match(/unknown argument '--big_bug'.  Did you mean: \[--big-bug\] \?$/, err.message)
#    end
#    
#  end
#
#  def test_syntax_check
#    parser.opt "arg"
#
#    parser.parse(%w(--arg))
#    parser.parse(%w(arg))
#    expect_raises(CommandlineError) { parser.parse(%w(---arg)) }
#    expect_raises(CommandlineError) { parser.parse(%w(-arg)) }
#  end
#
#  def test_required_flags_are_required
#    parser.opt "arg", "desc", :required => true
#    parser.opt "arg2", "desc", :required => false
#    parser.opt "arg3", "desc", :required => false
#
#    parser.parse(%w(--arg))
#    parser.parse(%w(--arg --arg2))
#    expect_raises(CommandlineError) { parser.parse(%w(--arg2)) }
#    expect_raises(CommandlineError) { parser.parse(%w(--arg2 --arg3)) }
#  end
#
#  ## flags that take an argument error unless given one
#  def test_argflags_demand_args
#    parser.opt "goodarg", "desc", cls: String
#    parser.opt "goodarg2", "desc", cls: String
#
#    parser.parse(%w(--goodarg goat))
#    expect_raises(CommandlineError) { parser.parse(%w(--goodarg --goodarg2 goat)) }
#    expect_raises(CommandlineError) { parser.parse(%w(--goodarg)) }
#  end
#
#  ## flags that don't take arguments ignore them
#  def test_arglessflags_refuse_args
#    parser.opt "goodarg"
#    parser.opt "goodarg2"
#    parser.parse(%w(--goodarg))
#    parser.parse(%w(--goodarg --goodarg2))
#    opts = parser.parse %w(--goodarg a)
#    assert_equal true, opts["goodarg"]
#    assert_equal ["a"], parser.leftovers
#  end
#
#  ## flags that require args of a specific type refuse args of other
#  ## types
  it "refuses args of other types" do
    parser.opt :goodarg, "desc", cls: IntOption
    #BROKEN# expect_raises(ArgumentError) { parser.opt "badarg", "desc", cls: String }
    parser.parse(%w(--goodarg 3))
    expect_raises(CommandlineError) { parser.parse(%w(--goodarg 4.2)) }
    expect_raises(CommandlineError) { parser.parse(%w(--goodarg hello)) }
  end
#
#  ## type is correctly derived from :default
#  def test_type_correctly_derived_from_default
#    expect_raises(ArgumentError) { parser.opt "badarg", "desc", default: [] }
#    expect_raises(ArgumentError) { parser.opt "badarg3", "desc", default: [{1 => 2}] }
#    expect_raises(ArgumentError) { parser.opt "badarg4", "desc", default: Hash.new }
#
#    # single arg: int
#    parser.opt "argsi", "desc", default: 0
#    opts = parser.parse(%w(--))
#    assert_equal 0, opts["argsi"]
#    opts = parser.parse(%w(--argsi 4))
#    assert_equal 4, opts["argsi"]
#    opts = parser.parse(%w(--argsi=4))
#    assert_equal 4, opts["argsi"]
#    opts = parser.parse(%w(--argsi=-4))
#    assert_equal( -4, opts["argsi"])
#
#    expect_raises(CommandlineError) { parser.parse(%w(--argsi 4.2)) }
#    expect_raises(CommandlineError) { parser.parse(%w(--argsi hello)) }
#
#    # single arg: float
#    parser.opt "argsf", "desc", default: 3.14
#    opts = parser.parse(%w(--))
#    assert_equal 3.14, opts["argsf"]
#    opts = parser.parse(%w(--argsf 2.41))
#    assert_equal 2.41, opts["argsf"]
#    opts = parser.parse(%w(--argsf 2))
#    assert_equal 2, opts["argsf"]
#    opts = parser.parse(%w(--argsf 1.0e-2))
#    assert_equal 1.0e-2, opts["argsf"]
#    expect_raises(CommandlineError) { parser.parse(%w(--argsf hello)) }
#
#    # single arg: date
#    date = Date.today
#    parser.opt "argsd", "desc", default: date
#    opts = parser.parse(%w(--))
#    assert_equal Date.today, opts["argsd"]
#    opts = parser.parse(['--argsd', 'Jan 4, 2007'])
#    assert_equal Date.civil(2007, 1, 4), opts["argsd"]
#    expect_raises(CommandlineError) { parser.parse(%w(--argsd hello)) }
#
#    # single arg: string
#    parser.opt "argss", "desc", default: "foobar"
#    opts = parser.parse(%w(--))
#    assert_equal "foobar", opts["argss"]
#    opts = parser.parse(%w(--argss 2.41))
#    assert_equal "2.41", opts["argss"]
#    opts = parser.parse(%w(--argss hello))
#    assert_equal "hello", opts["argss"]
#
#    # multi args: ints
#    parser.opt "argmi", "desc", default: [3, 5]
#    opts = parser.parse(%w(--))
#    assert_equal [3, 5], opts["argmi"]
#    opts = parser.parse(%w(--argmi 4))
#    assert_equal [4], opts["argmi"]
#    expect_raises(CommandlineError) { parser.parse(%w(--argmi 4.2)) }
#    expect_raises(CommandlineError) { parser.parse(%w(--argmi hello)) }
#
#    # multi args: floats
#    parser.opt "argmf", "desc", default: [3.34, 5.21]
#    opts = parser.parse(%w(--))
#    assert_equal [3.34, 5.21], opts["argmf"]
#    opts = parser.parse(%w(--argmf 2))
#    assert_equal [2], opts["argmf"]
#    opts = parser.parse(%w(--argmf 4.0))
#    assert_equal [4.0], opts["argmf"]
#    expect_raises(CommandlineError) { parser.parse(%w(--argmf hello)) }
#
#    # multi args: dates
#    dates = [Date.today, Date.civil(2007, 1, 4)]
#    parser.opt "argmd", "desc", default: dates
#    opts = parser.parse(%w(--))
#    assert_equal dates, opts["argmd"]
#    opts = parser.parse(['--argmd', 'Jan 4, 2007'])
#    assert_equal [Date.civil(2007, 1, 4)], opts["argmd"]
#    expect_raises(CommandlineError) { parser.parse(%w(--argmd hello)) }
#
#    # multi args: strings
#    parser.opt "argmst", "desc", default: %w(hello world)
#    opts = parser.parse(%w(--))
#    assert_equal %w(hello world), opts["argmst"]
#    opts = parser.parse(%w(--argmst 3.4))
#    assert_equal ["3.4"], opts["argmst"]
#    opts = parser.parse(%w(--argmst goodbye))
#    assert_equal ["goodbye"], opts["argmst"]
#  end
#
#  ## :type and :default must match if both are specified
#  def test_type_and_default_must_match
#    expect_raises(ArgumentError) { parser.opt "badarg", "desc", cls: :int, default: "hello" }
#    expect_raises(ArgumentError) { parser.opt "badarg2", "desc", cls: :String, default: 4 }
#    expect_raises(ArgumentError) { parser.opt "badarg2", "desc", cls: :String, default: ["hi"] }
#    expect_raises(ArgumentError) { parser.opt "badarg2", "desc", cls: :ints, default: [3.14] }
#
#    parser.opt "argsi", "desc", cls: :int, default: 4
#    parser.opt "argsf", "desc", cls: :float, default: 3.14
#    parser.opt "argsd", "desc", cls: :date, default: Date.today
#    parser.opt "argss", "desc", cls: :string, default: "yo"
#    parser.opt "argmi", "desc", cls: :ints, default: [4]
#    parser.opt "argmf", "desc", cls: :floats, default: [3.14]
#    parser.opt "argmd", "desc", cls: :dates, default: [Date.today]
#    parser.opt "argmst", "desc", cls: :strings, default: ["yo"]
#  end
#
#  ##
#  def test_flags_with_defaults_and_no_args_act_as_switches
#    parser.opt :argd, "desc", default: "default_string"
#
#    opts = parser.parse(%w(--))
#    assert !opts[:argd_given]
#    assert_equal "default_string", opts[:argd]
#
#    opts = parser.parse(%w( --argd ))
#    assert opts[:argd_given]
#    assert_equal "default_string", opts[:argd]
#
#    opts = parser.parse(%w(--argd different_string))
#    assert opts[:argd_given]
#    assert_equal "different_string", opts[:argd]
#  end
#
#  def test_flag_with_no_defaults_and_no_args_act_as_switches_array
#    parser.opt :argd, "desc", cls: :strings, default: ["default_string"]
#    opts = parser.parse(%w(--argd))
#    assert_equal ["default_string"], opts[:argd]
#  end
#
#  def test_type_and_empty_array
#    parser.opt "argmi", "desc", cls: :ints, default: []
#    parser.opt "argmf", "desc", cls: :floats, default: []
#    parser.opt "argmd", "desc", cls: :dates, default: []
#    parser.opt "argms", "desc", cls: :strings, default: []
#    expect_raises(ArgumentError) { parser.opt "badi", "desc", cls: :int, default: [] }
#    expect_raises(ArgumentError) { parser.opt "badf", "desc", cls: :float, default: [] }
#    expect_raises(ArgumentError) { parser.opt "badd", "desc", cls: :date, default: [] }
#    expect_raises(ArgumentError) { parser.opt "bads", "desc", cls: :string, default: [] }
#    opts = parser.parse([])
#    assert_equal(opts["argmi"], [])
#    assert_equal(opts["argmf"], [])
#    assert_equal(opts["argmd"], [])
#    assert_equal(opts["argms"], [])
#  end
#
#  def test_long_detects_bad_names
#    parser.opt "goodarg", "desc", :long => "none"
#    parser.opt "goodarg2", "desc", :long => "--two"
#    expect_raises(ArgumentError) { parser.opt "badarg", "desc", :long => "" }
#    expect_raises(ArgumentError) { parser.opt "badarg2", "desc", :long => "--" }
#    expect_raises(ArgumentError) { parser.opt "badarg3", "desc", :long => "-one" }
#    expect_raises(ArgumentError) { parser.opt "badarg4", "desc", :long => "---toomany" }
#  end
#
#  def test_short_detects_bad_names
#    parser.opt "goodarg", "desc", :short => "a"
#    parser.opt "goodarg2", "desc", :short => "-b"
#    expect_raises(ArgumentError) { parser.opt "badarg", "desc", :short => "" }
#    expect_raises(ArgumentError) { parser.opt "badarg2", "desc", :short => "-ab" }
#    expect_raises(ArgumentError) { parser.opt "badarg3", "desc", :short => "--t" }
#  end
#
#  def test_short_names_created_automatically
#    parser.opt "arg"
#    parser.opt "arg2"
#    parser.opt "arg3"
#    opts = parser.parse %w(-a -g)
#    assert_equal true, opts["arg"]
#    assert_equal false, opts["arg2"]
#    assert_equal true, opts["arg3"]
#  end
#
#  def test_short_autocreation_skips_dashes_and_numbers
#    parser.opt :arg # auto: a
#    parser.opt :arg_potato # auto: r
#    parser.opt :arg_muffin # auto: g
#    parser.opt :arg_daisy  # auto: d (not _)!
#    parser.opt :arg_r2d2f  # auto: f (not 2)!
#
#    opts = parser.parse %w(-f -d)
#    assert_equal true, opts[:arg_daisy]
#    assert_equal true, opts[:arg_r2d2f]
#    assert_equal false, opts[:arg]
#    assert_equal false, opts[:arg_potato]
#    assert_equal false, opts[:arg_muffin]
#  end
#
#  def test_short_autocreation_is_ok_with_running_out_of_chars
#    parser.opt :arg1 # auto: a
#    parser.opt :arg2 # auto: r
#    parser.opt :arg3 # auto: g
#    parser.opt :arg4 # auto: uh oh!
#    parser.parse []
#  end
#
#  def test_short_can_be_nothing
#    parser.opt "arg", "desc", :short => :none
#    parser.parse []
#
#    sio = StringIO.new "w"
#    parser.educate sio
#    assert sio.string =~ /--arg\s+desc/
#
#    expect_raises(CommandlineError) { parser.parse %w(-a) }
#  end
#
#  ## two args can't have the same name
#  def test_conflicting_names_are_detected
#    parser.opt "goodarg"
#    expect_raises(ArgumentError) { parser.opt "goodarg" }
#  end
#
#  ## two args can't have the same :long
#  def test_conflicting_longs_detected
#    parser.opt "goodarg", "desc", :long => "--goodarg"
#    expect_raises(ArgumentError) { parser.opt "badarg", "desc", :long => "--goodarg" }
#  end
#
#  ## two args can't have the same :short
#  def test_conflicting_shorts_detected
#    parser.opt "goodarg", "desc", :short => "-g"
#    expect_raises(ArgumentError) { parser.opt "badarg", "desc", :short => "-g" }
#  end
#
#  ## note: this behavior has changed in optimist 2.0!
#  def test_flag_parameters
#    parser.opt :defaultnone, "desc"
#    parser.opt :defaultfalse, "desc", default: false
#    parser.opt :defaulttrue, "desc", default: true
#
#    ## default state
#    opts = parser.parse []
#    assert_equal false, opts[:defaultnone]
#    assert_equal false, opts[:defaultfalse]
#    assert_equal true, opts[:defaulttrue]
#
#    ## specifying turns them on, regardless of default
#    opts = parser.parse %w(--defaultfalse --defaulttrue --defaultnone)
#    assert_equal true, opts[:defaultnone]
#    assert_equal true, opts[:defaultfalse]
#    assert_equal true, opts[:defaulttrue]
#
#    ## using --no- form turns them off, regardless of default
#    opts = parser.parse %w(--no-defaultfalse --no-defaulttrue --no-defaultnone)
#    assert_equal false, opts[:defaultnone]
#    assert_equal false, opts[:defaultfalse]
#    assert_equal false, opts[:defaulttrue]
#  end
#
#  ## note: this behavior has changed in optimist 2.0!
#  def test_flag_parameters_for_inverted_flags
#    parser.opt :no_default_none, "desc"
#    parser.opt :no_default_false, "desc", default: false
#    parser.opt :no_default_true, "desc", default: true
#
#    ## default state
#    opts = parser.parse []
#    assert_equal false, opts[:no_default_none]
#    assert_equal false, opts[:no_default_false]
#    assert_equal true, opts[:no_default_true]
#
#    ## specifying turns them all on, regardless of default
#    opts = parser.parse %w(--no-default-false --no-default-true --no-default-none)
#    assert_equal true, opts[:no_default_none]
#    assert_equal true, opts[:no_default_false]
#    assert_equal true, opts[:no_default_true]
#
#    ## using dropped-no form turns them all off, regardless of default
#    opts = parser.parse %w(--default-false --default-true --default-none)
#    assert_equal false, opts[:no_default_none]
#    assert_equal false, opts[:no_default_false]
#    assert_equal false, opts[:no_default_true]
#
#    ## disallow double negatives for reasons of sanity preservation
#    expect_raises(CommandlineError) { parser.parse %w(--no-no-default-true) }
#  end
#
#  def test_short_options_combine
#    parser.opt :arg1, "desc", :short => "a"
#    parser.opt :arg2, "desc", :short => "b"
#    parser.opt :arg3, "desc", :short => "c", cls: :int
#
#    opts = parser.parse %w(-a -b)
#    assert_equal true, opts[:arg1]
#    assert_equal true, opts[:arg2]
#    assert_nil opts[:arg3]
#
#    opts = parser.parse %w(-ab)
#    assert_equal true, opts[:arg1]
#    assert_equal true, opts[:arg2]
#    assert_nil opts[:arg3]
#
#    opts = parser.parse %w(-ac 4 -b)
#    assert_equal true, opts[:arg1]
#    assert_equal true, opts[:arg2]
#    assert_equal 4, opts[:arg3]
#
#    expect_raises(CommandlineError) { parser.parse %w(-cab 4) }
#    expect_raises(CommandlineError) { parser.parse %w(-cba 4) }
#  end
#
#  def test_doubledash_ends_option_processing
#    parser.opt :arg1, "desc", :short => "a", default: 0
#    parser.opt :arg2, "desc", :short => "b", default: 0
#    opts = parser.parse %w(-- -a 3 -b 2)
#    assert_equal opts[:arg1], 0
#    assert_equal opts[:arg2], 0
#    assert_equal %w(-a 3 -b 2), parser.leftovers
#    opts = parser.parse %w(-a 3 -- -b 2)
#    assert_equal opts[:arg1], 3
#    assert_equal opts[:arg2], 0
#    assert_equal %w(-b 2), parser.leftovers
#    opts = parser.parse %w(-a 3 -b 2 --)
#    assert_equal opts[:arg1], 3
#    assert_equal opts[:arg2], 2
#    assert_equal %w(), parser.leftovers
#  end
#
#  def test_wrap
#    assert_equal [""], parser.wrap("")
#    assert_equal ["a"], parser.wrap("a")
#    assert_equal ["one two", "three"], parser.wrap("one two three", :width => 8)
#    assert_equal ["one two three"], parser.wrap("one two three", :width => 80)
#    assert_equal ["one", "two", "three"], parser.wrap("one two three", :width => 3)
#    assert_equal ["onetwothree"], parser.wrap("onetwothree", :width => 3)
#    assert_equal [
#      "Test is an awesome program that does something very, very important.",
#      "",
#      "Usage:",
#      "  test [options] <filenames>+",
#      "where [options] are:"], parser.wrap(<<EOM, :width => 100)
#Test is an awesome program that does something very, very important.
#
#Usage:
#  test [options] <filenames>+
#where [options] are:
#EOM
#  end
#
#  def test_multi_line_description
#    out = StringIO.new
#    parser.opt :arg, <<-EOM, cls: :int
#This is an arg
#with a multi-line description
#    EOM
#    parser.educate(out)
#    assert_equal <<-EOM, out.string
#Options:
#  --arg=<i>    This is an arg
#               with a multi-line description
#    EOM
#  end
#
#  def test_integer_formatting
#    parser.opt :arg, "desc", cls: :integer, :short => "i"
#    opts = parser.parse %w(-i 5)
#    assert_equal 5, opts[:arg]
#  end
#
#  def test_integer_formatting_default
#    parser.opt :arg, "desc", cls: :integer, :short => "i", default: 3
#    opts = parser.parse %w(-i)
#    assert_equal 3, opts[:arg]
#  end
#
#  def test_floating_point_formatting
#    parser.opt :arg, "desc", cls: :float, :short => "f"
#    opts = parser.parse %w(-f 1)
#    assert_equal 1.0, opts[:arg]
#    opts = parser.parse %w(-f 1.0)
#    assert_equal 1.0, opts[:arg]
#    opts = parser.parse %w(-f 0.1)
#    assert_equal 0.1, opts[:arg]
#    opts = parser.parse %w(-f .1)
#    assert_equal 0.1, opts[:arg]
#    opts = parser.parse %w(-f .99999999999999999999)
#    assert_equal 1.0, opts[:arg]
#    opts = parser.parse %w(-f -1)
#    assert_equal(-1.0, opts[:arg])
#    opts = parser.parse %w(-f -1.0)
#    assert_equal(-1.0, opts[:arg])
#    opts = parser.parse %w(-f -0.1)
#    assert_equal(-0.1, opts[:arg])
#    opts = parser.parse %w(-f -.1)
#    assert_equal(-0.1, opts[:arg])
#    expect_raises(CommandlineError) { parser.parse %w(-f a) }
#    expect_raises(CommandlineError) { parser.parse %w(-f 1a) }
#    expect_raises(CommandlineError) { parser.parse %w(-f 1.a) }
#    expect_raises(CommandlineError) { parser.parse %w(-f a.1) }
#    expect_raises(CommandlineError) { parser.parse %w(-f 1.0.0) }
#    expect_raises(CommandlineError) { parser.parse %w(-f .) }
#    expect_raises(CommandlineError) { parser.parse %w(-f -.) }
#  end
#
#  def test_floating_point_formatting_default
#    parser.opt :arg, "desc", cls: :float, :short => "f", default: 5.5
#    opts = parser.parse %w(-f)
#    assert_equal 5.5, opts[:arg]
#  end
#
#  def test_date_formatting
#    parser.opt :arg, "desc", cls: :date, :short => 'd'
#    opts = parser.parse(['-d', 'Jan 4, 2007'])
#    assert_equal Date.civil(2007, 1, 4), opts[:arg]
#  end
#
#  def test_chronic_date_formatting
#    # note: only works with chronic gem
#    require 'optimist_xl/chronic'
#    parser.opt :arg, "chronic", cls: :chronic_date, :short => 'd'
#    opts = parser.parse(['-d', 'today'])
#    assert_equal Date.today, opts[:arg]
#  rescue LoadError
#  end
#  
#  def test_short_options_cant_be_numeric
#    expect_raises(ArgumentError) { parser.opt :arg, "desc", :short => "-1" }
#    parser.opt :a1b, "desc"
#    parser.opt :a2b, "desc"
#    parser.parse []
#    # testing private interface to ensure default
#    # short options did not become numeric
#    assert_equal parser.specs[:a1b].short.chars.first, 'a'
#    assert_equal parser.specs[:a2b].short.chars.first, 'b'
#  end
#
#  def test_short_options_can_be_weird
#    parser.opt :arg1, "desc", :short => "#"
#    parser.opt :arg2, "desc", :short => "."
#    expect_raises(ArgumentError) { parser.opt :arg3, "desc", :short => "-" }
#  end
#
#  def test_options_cant_be_set_multiple_times_if_not_specified
#    parser.opt :arg, "desc", :short => "-x"
#    parser.parse %w(-x)
#    expect_raises(CommandlineError) { parser.parse %w(-x -x) }
#    expect_raises(CommandlineError) { parser.parse %w(-xx) }
#  end
#
#  def test_options_can_be_set_multiple_times_if_specified
#    parser.opt :arg, "desc", :short => "-x", :multi => true
#    parser.parse %w(-x)
#    parser.parse %w(-x -x)
#    parser.parse %w(-xx)
#  end
#
#  def test_short_options_with_multiple_options
#    parser.opt :xarg, "desc", :short => "-x", cls: String, :multi => true
#    opts = parser.parse %w(-x a -x b)
#    assert_equal %w(a b), opts[:xarg]
#    assert_equal [], parser.leftovers
#  end
#
#  def test_short_options_with_multiple_options_does_not_affect_flags_type
#    parser.opt :xarg, "desc", :short => "-x", cls: :flag, :multi => true
#
#    opts = parser.parse %w(-x a)
#    assert_equal true, opts[:xarg]
#    assert_equal %w(a), parser.leftovers
#
#    opts = parser.parse %w(-x a -x b)
#    assert_equal true, opts[:xarg]
#    assert_equal %w(a b), parser.leftovers
#
#    opts = parser.parse %w(-xx a -x b)
#    assert_equal true, opts[:xarg]
#    assert_equal %w(a b), parser.leftovers
#  end
#
#  def test_short_options_with_multiple_arguments
#    parser.opt :xarg, "desc", cls: :ints
#    opts = parser.parse %w(-x 3 4 0)
#    assert_equal [3, 4, 0], opts[:xarg]
#    assert_equal [], parser.leftovers
#
#    parser.opt :yarg, "desc", cls: :floats
#    opts = parser.parse %w(-y 3.14 4.21 0.66)
#    assert_equal [3.14, 4.21, 0.66], opts[:yarg]
#    assert_equal [], parser.leftovers
#
#    parser.opt :zarg, "desc", cls: :strings
#    opts = parser.parse %w(-z a b c)
#    assert_equal %w(a b c), opts[:zarg]
#    assert_equal [], parser.leftovers
#  end
#
#  def test_short_options_with_multiple_options_and_arguments
#    parser.opt :xarg, "desc", cls: :ints, :multi => true
#    opts = parser.parse %w(-x 3 4 5 -x 6 7)
#    assert_equal [[3, 4, 5], [6, 7]], opts[:xarg]
#    assert_equal [], parser.leftovers
#
#    parser.opt :yarg, "desc", cls: :floats, :multi => true
#    opts = parser.parse %w(-y 3.14 4.21 5.66 -y 6.99 7.01)
#    assert_equal [[3.14, 4.21, 5.66], [6.99, 7.01]], opts[:yarg]
#    assert_equal [], parser.leftovers
#
#    parser.opt :zarg, "desc", cls: :strings, :multi => true
#    opts = parser.parse %w(-z a b c -z d e)
#    assert_equal [%w(a b c), %w(d e)], opts[:zarg]
#    assert_equal [], parser.leftovers
#  end
#
#  def test_combined_short_options_with_multiple_arguments
#    parser.opt :arg1, "desc", :short => "a"
#    parser.opt :arg2, "desc", :short => "b"
#    parser.opt :arg3, "desc", :short => "c", cls: :ints
#    parser.opt :arg4, "desc", :short => "d", cls: :floats
#
#    opts = parser.parse %w(-abc 4 6 9)
#    assert_equal true, opts[:arg1]
#    assert_equal true, opts[:arg2]
#    assert_equal [4, 6, 9], opts[:arg3]
#
#    opts = parser.parse %w(-ac 4 6 9 -bd 3.14 2.41)
#    assert_equal true, opts[:arg1]
#    assert_equal true, opts[:arg2]
#    assert_equal [4, 6, 9], opts[:arg3]
#    assert_equal [3.14, 2.41], opts[:arg4]
#
#    expect_raises(CommandlineError) { opts = parser.parse %w(-abcd 3.14 2.41) }
#  end
#
#  def test_long_options_with_multiple_options
#    parser.opt :xarg, "desc", cls: String, :multi => true
#    opts = parser.parse %w(--xarg=a --xarg=b)
#    assert_equal %w(a b), opts[:xarg]
#    assert_equal [], parser.leftovers
#    opts = parser.parse %w(--xarg a --xarg b)
#    assert_equal %w(a b), opts[:xarg]
#    assert_equal [], parser.leftovers
#  end
#
#  def test_long_options_with_multiple_arguments
#    parser.opt :xarg, "desc", cls: :ints
#    opts = parser.parse %w(--xarg 3 2 5)
#    assert_equal [3, 2, 5], opts[:xarg]
#    assert_equal [], parser.leftovers
#    opts = parser.parse %w(--xarg=3)
#    assert_equal [3], opts[:xarg]
#    assert_equal [], parser.leftovers
#
#    parser.opt :yarg, "desc", cls: :floats
#    opts = parser.parse %w(--yarg 3.14 2.41 5.66)
#    assert_equal [3.14, 2.41, 5.66], opts[:yarg]
#    assert_equal [], parser.leftovers
#    opts = parser.parse %w(--yarg=3.14)
#    assert_equal [3.14], opts[:yarg]
#    assert_equal [], parser.leftovers
#
#    parser.opt :zarg, "desc", cls: :strings
#    opts = parser.parse %w(--zarg a b c)
#    assert_equal %w(a b c), opts[:zarg]
#    assert_equal [], parser.leftovers
#    opts = parser.parse %w(--zarg=a)
#    assert_equal %w(a), opts[:zarg]
#    assert_equal [], parser.leftovers
#  end
#
#  def test_long_options_with_multiple_options_and_arguments
#    parser.opt :xarg, "desc", cls: :ints, :multi => true
#    opts = parser.parse %w(--xarg 3 2 5 --xarg 2 1)
#    assert_equal [[3, 2, 5], [2, 1]], opts[:xarg]
#    assert_equal [], parser.leftovers
#    opts = parser.parse %w(--xarg=3 --xarg=2)
#    assert_equal [[3], [2]], opts[:xarg]
#    assert_equal [], parser.leftovers
#
#    parser.opt :yarg, "desc", cls: :floats, :multi => true
#    opts = parser.parse %w(--yarg 3.14 2.72 5 --yarg 2.41 1.41)
#    assert_equal [[3.14, 2.72, 5], [2.41, 1.41]], opts[:yarg]
#    assert_equal [], parser.leftovers
#    opts = parser.parse %w(--yarg=3.14 --yarg=2.41)
#    assert_equal [[3.14], [2.41]], opts[:yarg]
#    assert_equal [], parser.leftovers
#
#    parser.opt :zarg, "desc", cls: :strings, :multi => true
#    opts = parser.parse %w(--zarg a b c --zarg d e)
#    assert_equal [%w(a b c), %w(d e)], opts[:zarg]
#    assert_equal [], parser.leftovers
#    opts = parser.parse %w(--zarg=a --zarg=d)
#    assert_equal [%w(a), %w(d)], opts[:zarg]
#    assert_equal [], parser.leftovers
#  end
#
#  def test_long_options_also_take_equals
#    parser.opt :arg, "desc", :long => "arg", cls: String, default: "hello"
#    opts = parser.parse %w()
#    assert_equal "hello", opts[:arg]
#    opts = parser.parse %w(--arg goat)
#    assert_equal "goat", opts[:arg]
#    opts = parser.parse %w(--arg=goat)
#    assert_equal "goat", opts[:arg]
#    ## actually, this next one is valid. empty string for --arg, and goat as a
#    ## leftover.
#    ## expect_raises(CommandlineError) { opts = parser.parse %w(--arg= goat) }
#  end
#
#  def test_auto_generated_long_names_convert_underscores_to_hyphens
#    parser.opt :hello_there
#    assert_equal "hello-there", parser.specs[:hello_there].long.long
#  end
#
#  def test_arguments_passed_through_block
#    @goat = 3
#    boat = 4
#    Parser.new(@goat) do |goat|
#      boat = goat
#    end
#    assert_equal @goat, boat
#  end
#  
#  ## test-only access reader method so that we dont have to
#  ## expose settings in the public API.
#  class OptimistXL::Parser
#    def get_settings_for_testing ; return @settings ;end
#  end
#  
#  def test_two_arguments_passed_through_block
#    newp = Parser.new(:abcd => 123, :efgh => "other" ) do |i|
#    end
#    assert_equal newp.get_settings_for_testing[:abcd], 123
#    assert_equal newp.get_settings_for_testing[:efgh], "other"
#  end
#
#
#  def test_version_and_help_override_errors
#    parser.opt :asdf, "desc", cls: String
#    parser.version "version"
#    parser.parse %w(--asdf goat)
#    expect_raises(CommandlineError) { parser.parse %w(--asdf) }
#    expect_raises(HelpNeeded) { parser.parse %w(--asdf --help) }
#    expect_raises(HelpNeeded) { parser.parse %w(--asdf -h) }
#    expect_raises(VersionNeeded) { parser.parse %w(--asdf --version) }
#  end
#
#  def test_conflicts
#    parser.opt :one
#    expect_raises(ArgumentError) { parser.conflicts :one, :two }
#    parser.opt :two
#    parser.conflicts :one, :two
#    parser.parse %w(--one)
#    parser.parse %w(--two)
#    expect_raises(CommandlineError) { parser.parse %w(--one --two) }
#
#    parser.opt :hello
#    parser.opt :yellow
#    parser.opt :mellow
#    parser.opt :jello
#    parser.conflicts :hello, :yellow, :mellow, :jello
#    expect_raises(CommandlineError) { parser.parse %w(--hello --yellow --mellow --jello) }
#    expect_raises(CommandlineError) { parser.parse %w(--hello --mellow --jello) }
#    expect_raises(CommandlineError) { parser.parse %w(--hello --jello) }
#
#    parser.parse %w(--hello)
#    parser.parse %w(--jello)
#    parser.parse %w(--yellow)
#    parser.parse %w(--mellow)
#
#    parser.parse %w(--mellow --one)
#    parser.parse %w(--mellow --two)
#
#    expect_raises(CommandlineError) { parser.parse %w(--mellow --two --jello) }
#    expect_raises(CommandlineError) { parser.parse %w(--one --mellow --two --jello) }
#  end
#
#  def test_conflict_error_messages
#    parser.opt :one
#    parser.opt "two"
#    parser.conflicts :one, "two"
#
#    expect_raises(CommandlineError, /--one.*--two/) { parser.parse %w(--one --two) }
#  end
#
#  def test_depends
#    parser.opt :one
#    expect_raises(ArgumentError) { parser.depends :one, :two }
#    parser.opt :two
#    parser.depends :one, :two
#    parser.parse %w(--one --two)
#    expect_raises(CommandlineError) { parser.parse %w(--one) }
#    expect_raises(CommandlineError) { parser.parse %w(--two) }
#
#    parser.opt :hello
#    parser.opt :yellow
#    parser.opt :mellow
#    parser.opt :jello
#    parser.depends :hello, :yellow, :mellow, :jello
#    parser.parse %w(--hello --yellow --mellow --jello)
#    expect_raises(CommandlineError) { parser.parse %w(--hello --mellow --jello) }
#    expect_raises(CommandlineError) { parser.parse %w(--hello --jello) }
#
#    expect_raises(CommandlineError) { parser.parse %w(--hello) }
#    expect_raises(CommandlineError) { parser.parse %w(--mellow) }
#
#    parser.parse %w(--hello --yellow --mellow --jello --one --two)
#    parser.parse %w(--hello --yellow --mellow --jello --one --two a b c)
#
#    expect_raises(CommandlineError) { parser.parse %w(--mellow --two --jello --one) }
#  end
#
#  def test_depend_error_messages
#    parser.opt :one
#    parser.opt "two"
#    parser.depends :one, "two"
#
#    parser.parse %w(--one --two)
#
#    expect_raises(CommandlineError, /--one.*--two/) { parser.parse %w(--one) }
#    expect_raises(CommandlineError, /--one.*--two/) { parser.parse %w(--two) }
#  end
#
#  ## courtesy neill zero
#  def test_two_required_one_missing_accuses_correctly
#    parser.opt "arg1", "desc1", :required => true
#    parser.opt "arg2", "desc2", :required => true
#
#    expect_raises(CommandlineError, /arg2/) { parser.parse(%w(--arg1)) }
#    expect_raises(CommandlineError, /arg1/) { parser.parse(%w(--arg2)) }
#    parser.parse(%w(--arg1 --arg2))
#  end
#
#  def test_stopwords_mixed
#    parser.opt "arg1", default: false
#    parser.opt "arg2", default: false
#    parser.stop_on %w(happy sad)
#
#    opts = parser.parse %w(--arg1 happy --arg2)
#    assert_equal true, opts["arg1"]
#    assert_equal false, opts["arg2"]
#
#    ## restart parsing
#    parser.leftovers.shift
#    opts = parser.parse parser.leftovers
#    assert_equal false, opts["arg1"]
#    assert_equal true, opts["arg2"]
#  end
#
#  def test_stopwords_no_stopwords
#    parser.opt "arg1", default: false
#    parser.opt "arg2", default: false
#    parser.stop_on %w(happy sad)
#
#    opts = parser.parse %w(--arg1 --arg2)
#    assert_equal true, opts["arg1"]
#    assert_equal true, opts["arg2"]
#
#    ## restart parsing
#    parser.leftovers.shift
#    opts = parser.parse parser.leftovers
#    assert_equal false, opts["arg1"]
#    assert_equal false, opts["arg2"]
#  end
#
#  def test_stopwords_multiple_stopwords
#    parser.opt "arg1", default: false
#    parser.opt "arg2", default: false
#    parser.stop_on %w(happy sad)
#
#    opts = parser.parse %w(happy sad --arg1 --arg2)
#    assert_equal false, opts["arg1"]
#    assert_equal false, opts["arg2"]
#
#    ## restart parsing
#    parser.leftovers.shift
#    opts = parser.parse parser.leftovers
#    assert_equal false, opts["arg1"]
#    assert_equal false, opts["arg2"]
#
#    ## restart parsing again
#    parser.leftovers.shift
#    opts = parser.parse parser.leftovers
#    assert_equal true, opts["arg1"]
#    assert_equal true, opts["arg2"]
#  end
#
#  def test_stopwords_with_short_args
#    parser.opt :global_option, "This is a global option", :short => "-g"
#    parser.stop_on %w(sub-command-1 sub-command-2)
#
#    global_opts = parser.parse %w(-g sub-command-1 -c)
#    cmd = parser.leftovers.shift
#
#    @q = Parser.new
#    @q.opt :cmd_option, "This is an option only for the subcommand", :short => "-c"
#    cmd_opts = @q.parse parser.leftovers
#
#    assert_equal true, global_opts[:global_option]
#    assert_nil global_opts[:cmd_option]
#
#    assert_equal true, cmd_opts[:cmd_option]
#    assert_nil cmd_opts[:global_option]
#
#    assert_equal cmd, "sub-command-1"
#    assert_equal @q.leftovers, []
#  end
#
#  def test_unknown_subcommand
#    parser.opt :global_flag, "Global flag", :short => "-g", cls: :flag
#    parser.opt :global_param, "Global parameter", :short => "-p", default: 5
#    parser.stop_on_unknown
#
#    expected_opts = { :global_flag => true, :help => false, :global_param => 5, :global_flag_given => true }
#    expected_leftovers = [ "my_subcommand", "-c" ]
#
#    assert_parses_correctly parser, %w(--global-flag my_subcommand -c), \
#      expected_opts, expected_leftovers
#    assert_parses_correctly parser, %w(-g my_subcommand -c), \
#      expected_opts, expected_leftovers
#
#    expected_opts = { :global_flag => false, :help => false, :global_param => 5, :global_param_given => true }
#    expected_leftovers = [ "my_subcommand", "-c" ]
#
#    assert_parses_correctly parser, %w(-p 5 my_subcommand -c), \
#      expected_opts, expected_leftovers
#    assert_parses_correctly parser, %w(--global-param 5 my_subcommand -c), \
#      expected_opts, expected_leftovers
#  end
#
#  def test_alternate_args
#    args = %w(-a -b -c)
#
#    opts = ::OptimistXL.options(args) do
#      opt :alpher, "Ralph Alpher", :short => "-a"
#      opt :bethe, "Hans Bethe", :short => "-b"
#      opt :gamow, "George Gamow", :short => "-c"
#    end
#
#    physicists_with_humor = [:alpher, :bethe, :gamow]
#    physicists_with_humor.each do |physicist|
#      assert_equal true, opts[physicist]
#    end
#  end
#
#  def test_date_arg_type
#    temp = Date.new
#    parser.opt :arg, 'desc', cls: :date
#    parser.opt :arg2, 'desc', cls: Date
#    parser.opt :arg3, 'desc', default: temp
#
#    opts = parser.parse []
#    assert_equal temp, opts[:arg3]
#
#    opts = parser.parse %w(--arg 2010/05/01)
#    assert_kind_of Date, opts[:arg]
#    assert_equal Date.new(2010, 5, 1), opts[:arg]
#
#    opts = parser.parse %w(--arg2 2010/9/13)
#    assert_kind_of Date, opts[:arg2]
#    assert_equal Date.new(2010, 9, 13), opts[:arg2]
#
#    opts = parser.parse %w(--arg3)
#    assert_equal temp, opts[:arg3]
#  end
#
#  def test_chronic_date_arg_type
#    require 'optimist_xl/chronic'
#    temp = Date.new
#    parser.opt :arg, 'desc', cls: :chronic_date
#    parser.opt :arg2, 'desc', cls: Chronic::Date
#    parser.opt :arg3, 'desc', default: temp
#
#    opts = parser.parse []
#    assert_equal temp, opts[:arg3]
#
#    opts = parser.parse %w(--arg 5/1/2010)
#    assert_kind_of Date, opts[:arg]
#    assert_equal Date.new(2010, 5, 1), opts[:arg]
#
#    opts = parser.parse %w(--arg2 5/1/2010)
#    assert_kind_of Date, opts[:arg2]
#    assert_equal Date.new(2010, 5, 1), opts[:arg2]
#
#    opts = parser.parse %w(--arg3)
#    assert_equal temp, opts[:arg3]
#  rescue LoadError
#  end    
#
#  def test_unknown_arg_class_type
#    expect_raises ArgumentError do
#      parser.opt :arg, 'desc', cls: Hash
#    end
#  end
#
#  def test_io_arg_type
#    parser.opt :arg, "desc", cls: :io
#    parser.opt :arg2, "desc", cls: IO
#    parser.opt :arg3, "desc", default: $stdout
#
#    opts = parser.parse []
#    assert_equal $stdout, opts[:arg3]
#
#    opts = parser.parse %w(--arg /dev/null)
#    assert_kind_of File, opts[:arg]
#    assert_equal "/dev/null", opts[:arg].path
#
#    #TODO: move to mocks
#    #opts = parser.parse %w(--arg2 http://google.com/)
#    #assert_kind_of StringIO, opts[:arg2]
#
#    opts = parser.parse %w(--arg3 stdin)
#    assert_equal $stdin, opts[:arg3]
#
#    expect_raises(CommandlineError) { opts = parser.parse %w(--arg /fdasfasef/fessafef/asdfasdfa/fesasf) }
#  end
#
#  def test_openstruct_style_access
#    parser.opt "arg1", "desc", cls: :int
#    parser.opt :arg2, "desc", cls: :int
#
#    opts = parser.parse(%w(--arg1 3 --arg2 4))
#
#    opts.arg1
#    opts.arg2
#    assert_equal 3, opts.arg1
#    assert_equal 4, opts.arg2
#  end
#
#  def test_multi_args_autobox_defaults
#    parser.opt :arg1, "desc", default: "hello", :multi => true
#    parser.opt :arg2, "desc", default: ["hello"], :multi => true
#
#    opts = parser.parse []
#    assert_equal ["hello"], opts[:arg1]
#    assert_equal ["hello"], opts[:arg2]
#
#    opts = parser.parse %w(--arg1 hello)
#    assert_equal ["hello"], opts[:arg1]
#    assert_equal ["hello"], opts[:arg2]
#
#    opts = parser.parse %w(--arg1 hello --arg1 there)
#    assert_equal ["hello", "there"], opts[:arg1]
#  end
#
#  def test_ambigious_multi_plus_array_default_resolved_as_specified_by_documentation
#    parser.opt :arg1, "desc", default: ["potato"], :multi => true
#    parser.opt :arg2, "desc", default: ["potato"], :multi => true, cls: :strings
#    parser.opt :arg3, "desc", default: ["potato"]
#    parser.opt :arg4, "desc", default: ["potato", "rhubarb"], :short => :none, :multi => true
#
#    ## arg1 should be multi-occurring but not multi-valued
#    opts = parser.parse %w(--arg1 one two)
#    assert_equal ["one"], opts[:arg1]
#    assert_equal ["two"], parser.leftovers
#
#    opts = parser.parse %w(--arg1 one --arg1 two)
#    assert_equal ["one", "two"], opts[:arg1]
#    assert_equal [], parser.leftovers
#
#    ## arg2 should be multi-valued and multi-occurring
#    opts = parser.parse %w(--arg2 one two)
#    assert_equal [["one", "two"]], opts[:arg2]
#    assert_equal [], parser.leftovers
#
#    ## arg3 should be multi-valued but not multi-occurring
#    opts = parser.parse %w(--arg3 one two)
#    assert_equal ["one", "two"], opts[:arg3]
#    assert_equal [], parser.leftovers
#
#    ## arg4 should be multi-valued but not multi-occurring
#    opts = parser.parse %w()
#    assert_equal ["potato", "rhubarb"], opts[:arg4]
#  end
#
#  def test_given_keys
#    parser.opt :arg1
#    parser.opt :arg2
#
#    opts = parser.parse %w(--arg1)
#    assert opts[:arg1_given]
#    assert !opts[:arg2_given]
#
#    opts = parser.parse %w(--arg2)
#    assert !opts[:arg1_given]
#    assert opts[:arg2_given]
#
#    opts = parser.parse []
#    assert !opts[:arg1_given]
#    assert !opts[:arg2_given]
#
#    opts = parser.parse %w(--arg1 --arg2)
#    assert opts[:arg1_given]
#    assert opts[:arg2_given]
#  end
#
  it "assigns default shorts only after user shorts" do
    parser.opt :aab, "aaa" # should be assigned to -b
    parser.opt :ccd, "bbb" # should be assigned to -d
    parser.opt :user1, "user1", short: 'a'
    parser.opt :user2, "user2", short: 'c'
    pp! parser
    opts = parser.parse %w(-a -b)
#    assert opts[:user1]
#    assert !opts[:user2]
#    assert opts[:aab]
#    assert !opts[:ccd]
#
    opts = parser.parse %w(-c -d)
#    assert !opts[:user1]
#    assert opts[:user2]
#    assert !opts[:aab]
#    assert opts[:ccd]
  end
#
#  def test_short_opts_not_implicitly_created
#    newp = Parser.new(explicit_short_opts: true)
#    newp.opt :user1, "user1"
#    newp.opt :bag, "bag", :short => 'b'
#    expect_raises(CommandlineError) do
#      newp.parse %w(-u)
#    end
#    opts = newp.parse %w(--user1)
#    assert opts[:user1]
#    opts = newp.parse %w(-b)
#    assert opts[:bag]
#  end
#
#  def test_inexact_match
#    newp = Parser.new()
#    newp.opt :liberation, "liberate something", cls: :int
#    newp.opt :evaluate, "evaluate something", cls: :string
#    opts = newp.parse %w(--lib 5 --ev bar)
#    assert_equal 5, opts[:liberation]
#    assert_equal 'bar', opts[:evaluate]
#    assert_nil opts[:eval]
#  end
#  
#  def test_exact_match
#    newp = Parser.new(exact_match: true)
#    newp.opt :liberation, "liberate something", cls: :int
#    newp.opt :evaluate, "evaluate something", cls: :string
#    expect_raises(CommandlineError, /unknown argument '--lib'/) do
#      newp.parse %w(--lib 5)
#    end
#    expect_raises_errmatch(CommandlineError, /unknown argument '--ev'/) do
#      newp.parse %w(--ev bar)
#    end
#  end
#
#  def test_inexact_collision
#    newp = Parser.new()
#    newp.opt :bookname, "name of a book", cls: :string
#    newp.opt :bookcost, "cost of the book", cls: :string
#    opts = newp.parse %w(--bookn hairy_potsworth --bookc 10)
#    assert_equal 'hairy_potsworth', opts[:bookname]
#    assert_equal '10', opts[:bookcost]
#    expect_raises(CommandlineError) do
#      newp.parse %w(--book 5) # ambiguous
#    end
#    ## partial match causes 'specified multiple times' error
#    expect_raises(CommandlineError, /specified multiple times/) do
#      newp.parse %w(--bookc 17 --bookcost 22)
#    end
#  end
#
#  def test_inexact_collision_with_exact
#    newp = Parser.new(:inexact_match => true)
#    newp.opt :book, "name of a book", cls: :string, default: "ABC"
#    newp.opt :bookcost, "cost of the book", cls: :int, default: 5
#    opts = newp.parse %w(--book warthog --bookc 3)
#    assert_equal 'warthog', opts[:book]
#    assert_equal 3, opts[:bookcost]
#
#  end
#
  it "accepts_arguments_with_spaces" do
    parser.opt :arg1, "arg", cls: StringOption
    parser.opt :arg2, "arg2", cls: StringOption
    opts = parser.parse ["--arg1", "hello there", "--arg2=hello there"]
    p! opts
    opts[:arg1].should eq "hello there"
    opts[:arg1].should eq "hello there"
    parser.leftovers.size.should eq 0
  end

#
#  def test_multi_args_default_to_empty_array
#    parser.opt :arg1, "arg", :multi => true
#    opts = parser.parse []
#    assert_equal [], opts[:arg1]
#  end
#
#  def test_simple_interface_handles_help
#    assert_stdout(/Options:/) do
#      expect_raises(SystemExit) do
#        ::OptimistXL::options(%w(-h)) do
#          opt :potato
#        end
#      end
#    end
#
#    # ensure regular status is returned
#
#    assert_stdout do
#      begin
#        ::OptimistXL::options(%w(-h)) do
#          opt :potato
#        end
#      rescue SystemExit => e
#        assert_equal 0, e.status
#      end
#    end
#  end
#
#  def test_simple_interface_handles_version
#    assert_stdout(/1.2/) do
#      expect_raises(SystemExit) do
#        ::OptimistXL::options(%w(-v)) do
#          version "1.2"
#          opt :potato
#        end
#      end
#    end
#  end
#
#  def test_simple_interface_handles_regular_usage
#    opts = ::OptimistXL::options(%w(--potato)) do
#      opt :potato
#    end
#    assert opts[:potato]
#  end
#
#  def test_simple_interface_handles_die
#    assert_stderr do
#      ::OptimistXL::options(%w(--potato)) do
#        opt :potato
#      end
#      expect_raises(SystemExit) { ::OptimistXL::die :potato, "is invalid" }
#    end
#  end
#
#  def test_simple_interface_handles_die_without_message
#    assert_stderr(/Error:/) do
#      ::OptimistXL::options(%w(--potato)) do
#        opt :potato
#      end
#      expect_raises(SystemExit) { ::OptimistXL::die :potato }
#    end
#  end
#
#  def test_invalid_option_with_simple_interface
#    assert_stderr do
#      expect_raises(SystemExit) do
#        ::OptimistXL.options(%w(--potato))
#      end
#    end
#
#    assert_stderr do
#      begin
#        ::OptimistXL.options(%w(--potato))
#      rescue SystemExit => e
#        assert_equal(-1, e.status)
#      end
#    end
#  end
#
#  def test_supports_callback_inline
#    expect_raises(RuntimeError, "good") do
#      parser.opt :cb1 do |_vals|
#        raise "good"
#      end
#      parser.parse(%w(--cb1))
#    end
#  end
#
#  def test_supports_callback_param
#    expect_raises(RuntimeError, "good") do
#      parser.opt :cb1, "with callback", :callback => lambda { |_vals| raise "good" }
#      parser.parse(%w(--cb1))
#    end
#  end
#
#  def test_ignore_invalid_options
#    parser.opt :arg1, "desc", cls: String
#    parser.opt :b, "desc", cls: String
#    parser.opt :c, "desc", cls: :flag
#    parser.opt :d, "desc", cls: :flag
#    parser.ignore_invalid_options = true
#    opts = parser.parse %w{unknown -S param --arg1 potato -fb daisy --foo -ecg --bar baz -z}
#    assert_equal "potato", opts[:arg1]
#    assert_equal "daisy", opts[:b]
#    assert opts[:c]
#    refute opts[:d]
#    assert_equal %w{unknown -S param -f --foo -eg --bar baz -z}, parser.leftovers
#  end
#
#  def test_ignore_invalid_options_stop_on_unknown_long
#    parser.opt :arg1, "desc", cls: String
#    parser.ignore_invalid_options = true
#    parser.stop_on_unknown
#    opts = parser.parse %w{--unk --arg1 potato}
#    refute opts[:arg1]
#    assert_equal %w{--unk --arg1 potato}, parser.leftovers
#  end
#
#  def test_ignore_invalid_options_stop_on_unknown_short
#    parser.opt :arg1, "desc", cls: String
#    parser.ignore_invalid_options = true
#    parser.stop_on_unknown
#    opts = parser.parse %w{-ua potato}
#    refute opts[:arg1]
#    assert_equal %w{-ua potato}, parser.leftovers
#  end
#
#  def test_ignore_invalid_options_stop_on_unknown_partial_end_short
#    parser.opt :arg1, "desc", cls: :flag
#    parser.ignore_invalid_options = true
#    parser.stop_on_unknown
#    opts = parser.parse %w{-au potato}
#    assert opts[:arg1]
#    assert_equal %w{-u potato}, parser.leftovers
#  end
#
#  def test_ignore_invalid_options_stop_on_unknown_partial_mid_short
#    parser.opt :arg1, "desc", cls: :flag
#    parser.ignore_invalid_options = true
#    parser.stop_on_unknown
#    opts = parser.parse %w{-abu potato}
#    assert opts[:arg1]
#    assert_equal %w{-bu potato}, parser.leftovers
#  end
#
#  # Due to strangeness in how the cloaker works, there were
#  # cases where OptimistXL.parse would work, but OptimistXL.options
#  # did not, depending on arguments given to the function.
#  # These serve to validate different args given to OptimistXL.options
#  def test_options_takes_hashy_settings
#    passargs_copy = []
#    settings_copy = []
#    ::OptimistXL.options(%w(--wig --pig), :fizz=>:buzz, :bear=>:cat) do |*passargs|
#      opt :wig
#      opt :pig
#      passargs_copy = passargs.dup
#      settings_copy = @settings
#    end
#    assert_equal [], passargs_copy
#    assert_equal settings_copy[:fizz], :buzz
#    assert_equal settings_copy[:bear], :cat
#  end
#  
#  def test_options_takes_some_other_data
#    passargs_copy = []
#    settings_copy = []
#    ::OptimistXL.options(%w(--nose --close), 1, 2, 3) do |*passargs|
#      opt :nose
#      opt :close
#      passargs_copy = passargs.dup
#      settings_copy = @settings
#    end
#    assert_equal [1,2,3], passargs_copy
#    assert_equal(::OptimistXL::Parser::DEFAULT_SETTINGS, settings_copy)
#  end
#end

end
